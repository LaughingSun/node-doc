'use strict';

/**
 * @todo Link callbacks with type in function params
 */

var markdown = require('markdown-creator');

/**
 * Prepare the documentation object to be saved.
 *
 * @param   doc       {Object} The documentation object.
 * @return            {Object} An object with filenames as keys and the value
 *                             is the documentation object in markdown. Main.md
 *                             is the default and one file for each namespace.
 *                             And todo.md for all the todos.
 * @return  .main.md  {String} The main documentation in markdown.
 * @return [.todo.md] {String} All todos from the project in markdown.
 */
function prepareMarkdown (doc) {
  var result = {};

  // Main file
  result['README.md'] = toMarkdown(doc);

  // Create a global todo file, with all todos in it
  if (doc.todos) result['TODO.md'] = parseTodos(doc.todos);

  // Handle namespaces
  var ns = doc.ns;
  for (var name in doc.ns) {
    if (ns.hasOwnProperty(name)) result[name + '.md'] = toMarkdown(ns[name]);
  }

  return result;
}

module.exports = prepareMarkdown;

/**
 * Parse a documentation object into Github flavored Markdown.
 *
 * @param  doc {Object} The documentation object.
 * @return     {String} The documentation in markdown.
 */
function toMarkdown (doc) {
  var md = markdown.title(doc.name, 1);

  // Add version information
  if (doc.version) md += markdown.quote('Version ' + doc.version);

  // Add the description
  if (doc.desc) md += markdown.text(doc.desc);

  // Add author information
  if (doc.author) {
    var author = 'Created by ' + doc.author.name.trim();

    if (doc.author.email) {
      var email = doc.author.email.trim();
      author += ', ' + markdown.link(email, 'mailto:' + email);
    }

    if (doc.author.url) {
      var url = doc.author.url.trim();
      author += ' (' + markdown.link(url, url) + ')';
    }

    md += markdown.text(author);
  }

  /** @todo Add contributers info */

  // Add license information
  if (doc.license) md += markdown.text('Released under a ' + doc.license.trim() + ' license.');

  // Add global todos
  if (doc.todos && doc.todos.global) {
    md += markdown.title('Todo', 2);
    md += markdown.list(doc.todos.global, 'checked');
  }

  // Add exports information
  if (doc.exports) {
    md += markdown.title('Exports', 2);
    var exports = doc.exports;

    if (exports.type === 'Function' ||  exports.type === 'Constructor') {
      md += parseFunction(exports);
    } else {
      md += parseDefault(exports);
    }
  }

  // Add functions information
  if (doc.functions) {
    md += markdown.title('Functions', 2);
    var functions = doc.functions;

    for (var fnName in functions) {
      if (functions.hasOwnProperty(fnName)) md += parseFunction(functions[fnName]);
    }
  }

  // Add constants information
  if (doc.constants) {
    md += markdown.title('Constants', 2);
    var constants = doc.constants;

    for (var constantName in constants) {
      if (constants.hasOwnProperty(constantName)) md += parseDefault(constants[constantName]);
    }
  }

  // Add callback information
  if (doc.callbacks) {
    md += markdown.title('Callbacks', 2);
    var callbacks = doc.callbacks;

    for (var callbackName in callbacks) {
      if (callbacks.hasOwnProperty(callbackName)) md += parseCallback(callbacks[callbackName]);
    }
  }

  // Add Node-doc information
  md += markdown.text('Generated by ' + markdown.link('Node-doc', 'https://github.com/Thomasdezeeuw/node-doc/', 'Node-doc'));

  // Drop the two extra new lines
  return md.slice(0, -2);
}

/**
 * Parse a function of the documentation object.
 *
 * @param  fn {Object} A function of the documentation object.
 * @return    {String} The function documentation in markdown.
 */
function parseFunction (fn) {
  var md = parseDefault(fn);

  if (fn.todos) {
    md += markdown.title('Todo', 4);
    md += markdown.list(fn.todos, 'checked');
  }

  if (fn.example) {
    md += markdown.title('Example', 4);
    md += markdown.code(fn.example, 'javascript');
  }

  if (fn.params) md += parseParams(fn.params);

  if (fn.this) {
    var ths = fn.this;

    md += markdown.title('This', 4);

    if (ths.desc) md += markdown.text(ths.desc);

    if (ths.properties) {
      md += markdown.title('Properties', 5);

      var props = ths.properties
        , prop;

      for (var name in props) {
        if (props.hasOwnProperty(name)) {
          prop = props[name];

          md += markdown.title(name, 6);

          if (prop.desc) md += markdown.text(prop.desc);
          if (prop.type) md += markdown.quote(prop.type);

          if (!prop.desc && !prop.type) md += markdown.text(markdown.italic('No further information avaiable'));
        }
      }
    }

    if (!ths.desc && !ths.properties) md += markdown.text(markdown.italic('No further information avaiable'));
  }

  if (fn.throws) {
    md += markdown.title('Possible errors', 4);

    var errors = [];

    fn.throws.forEach(function (error) {
      var err = [error.msg];
      if (error.cause) err.push(error.cause);
      errors.push(err);
    });

    md += markdown.table(['Message', 'Cause'], errors);
  }

  if (fn.return) {
    md += markdown.title('Return', 4);

    var rtn = fn.return;

    /** @todo DRY this with param */
    if (rtn.properties) {
      var rtns = [];

      rtns.push([
        '', // name
        rtn.desc || '',
        rtn.type || ''
      ]);

      var returnProps = rtn.properties
        , keys = Object.keys(returnProps);

      keys.forEach(function (name) {
        var rtn = returnProps[name];

        rtns.push([
          name,
          rtn.desc || '',
          rtn.type || ''
        ]);
      });

      md += markdown.table(['Name', 'Description', 'Type'], rtns);
    } else {
      var table = markdown.table(['Description', 'Type'], [[rtn.desc || '', rtn.type || '']]);

      if (table !== '') {
        md += table;
      } else {
        md += markdown.text(markdown.italic('No further information avaiable'));
      }
    }
  }

  return md;
}

/**
 * Parse a callback of the documentation object.
 *
 * @param  callback {Object} A callback of the documentation object.
 * @return          {String} The callback documentation in markdown.
 */
function parseCallback (callback) {
  var md = parseDefault(callback);
  if (callback.params) md += parseParams(callback.params);
  return md;
}

/**
 * Parse all todos of the documentation object.
 *
 * @param  todo {Object} All todos of the documentation object.
 * @return      {String} The todos in a markdown list.
 */
function parseTodos (todos) {
  var md = markdown.title('Todo', 1);

  if (todos.global) {
    md += markdown.list(todos.global, 'checked');
  }

  for (var list in todos) {
    if (list !== 'global') {
      md += markdown.title(list, 2);
      md += markdown.list(todos[list], 'checked');
    }
  }

  return md;
}

/**
 * Parse all params of a function.
 *
 * @param  docParams {Array}  All params of the function.
 * @return           {String} The params in a table.
 */
function parseParams (docParams) {
  var md = markdown.title('Params', 4);

  var params = [];

  docParams.forEach(function (param) {
    params.push([
      param.name,
      param.desc || '',
      param.type || '',
      param.optional === true ? 'Yes': ''
    ]);

    if (param.properties) {
      var props = param.properties
        , paramName = param.name
        , keys = Object.keys(props);

      keys.forEach(function (name) {
        var param = props[name];

        params.push([
          paramName + '.' + name,
          param.desc || '',
          param.type || '',
          param.optional === true ? 'Yes': ''
        ]);
      });
    }
  });

  md += markdown.table(['Name', 'Description', 'Type', 'Optional'], params);

  return md;
}

/**
 * Parse some default information about a item.
 *
 * @param  item              {Object} The item object.
 * @param  [item.name]       {String} The name of the item.
 * @param  [item.type]       {String} The type of the item.
 * @param  [item.deprecated] {String} If the item is deprecated.
 * @param  [item.access]     {String} Type of access of the item.
 * @param  [item.desc]       {String} Description of the item.
 * @return                   {String} Default information in markdown.
 */
function parseDefault (item) {
  var md = '';

  if (item.name) md += markdown.title(item.name, 3);

  if (item.type) {
    var quote = item.type;
    if (item.constant) quote += ', ' + markdown.bold('constant');
    if (item.deprecated) quote += ', ' + markdown.bold('deprecated');
    if (item.access) quote += ', ' + markdown.italic(item.access);
    md += markdown.quote(quote);
  }

  if (item.desc) md += markdown.text(item.desc);

  // Otherwise only the title appears, this looks slightly better
  if (!item.type && !item.desc) md += markdown.text(markdown.italic('No further information avaiable'));

  return md;
}
